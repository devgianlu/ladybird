#import <CredentialManagement/AuthenticatorResponse.idl>
#import <CredentialManagement/Credential.idl>

[SecureContext, Exposed=Window]
interface PublicKeyCredential : Credential {
    [SameObject] readonly attribute ArrayBuffer rawId;
    [SameObject] readonly attribute AuthenticatorResponse response;
    readonly attribute DOMString? authenticatorAttachment;
    AuthenticationExtensionsClientOutputs getClientExtensionResults();
    static Promise<boolean> isConditionalMediationAvailable();
    PublicKeyCredentialJSON toJSON();
};

// The structure of this object will be either
// RegistrationResponseJSON or AuthenticationResponseJSON
typedef object PublicKeyCredentialJSON;

dictionary AuthenticationExtensionsClientOutputs {
};

dictionary AuthenticationExtensionsClientInputs {
};

dictionary PublicKeyCredentialCreationOptions {
    required PublicKeyCredentialRpEntity rp;
    required PublicKeyCredentialUserEntity user;

    required BufferSource challenge;
    required sequence<PublicKeyCredentialParameters> pubKeyCredParams;

    unsigned long timeout;
    sequence<PublicKeyCredentialDescriptor> excludeCredentials = [];
    AuthenticatorSelectionCriteria authenticatorSelection;
    sequence<DOMString> hints = [];
    DOMString attestation = "none";
    sequence<DOMString> attestationFormats = [];
    AuthenticationExtensionsClientInputs extensions;
};

partial dictionary CredentialCreationOptions {
    PublicKeyCredentialCreationOptions publicKey;
};

dictionary PublicKeyCredentialRequestOptions {
    required BufferSource challenge;
    unsigned long timeout;
    DOMString rpId;
    sequence<PublicKeyCredentialDescriptor> allowCredentials = [];
    DOMString userVerification = "preferred";
    sequence<DOMString> hints = [];
    AuthenticationExtensionsClientInputs extensions;
};

partial dictionary CredentialRequestOptions {
    PublicKeyCredentialRequestOptions publicKey;
};

dictionary PublicKeyCredentialDescriptor {
    required DOMString type;
    required BufferSource id;
    sequence<DOMString> transports;
};

dictionary AuthenticatorSelectionCriteria {
    DOMString authenticatorAttachment;
    DOMString residentKey;
    boolean requireResidentKey = false;
    DOMString userVerification = "preferred";
};

typedef long COSEAlgorithmIdentifier;

dictionary PublicKeyCredentialParameters {
    required DOMString type;
    required COSEAlgorithmIdentifier alg;
};

dictionary PublicKeyCredentialEntity {
    required DOMString name;
};

dictionary PublicKeyCredentialRpEntity : PublicKeyCredentialEntity {
    DOMString id;
};

dictionary PublicKeyCredentialUserEntity : PublicKeyCredentialEntity {
    required BufferSource id;
    required DOMString displayName;
};

dictionary CollectedClientData {
    required DOMString type;
    required DOMString challenge;
    required DOMString origin;
    boolean crossOrigin;
    DOMString topOrigin;
};

dictionary TokenBinding {
    required DOMString status;
    DOMString id;
};

enum TokenBindingStatus { "present", "supported" };